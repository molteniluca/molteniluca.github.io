<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>home_r00ter - Luca Molteni&#39;s Blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Cyberchallenge.IT finals A/D challenge" />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="https://molteniluca.github.io/posts/homerooter/">
  <meta property="og:site_name" content="Luca Molteni&#39;s Blog">
  <meta property="og:title" content="home_r00ter">
  <meta property="og:description" content="Cyberchallenge.IT finals A/D challenge">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-10-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-10-10T00:00:00+00:00">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="home_r00ter">
  <meta name="twitter:description" content="Cyberchallenge.IT finals A/D challenge">

        <link href="https://molteniluca.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://molteniluca.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css" />
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://molteniluca.github.io/">Luca Molteni&#39;s Blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title">home_r00ter</h1>
          <div class="meta">Posted on Oct 10, 2020</div>
        </div>
        
        <section class="body">
          <p>(This writeup was written by me and <a href="https://twitter.com/kientuong114">Kien Tuong Truong</a>, check out also his <a href="https://ktruong.dev">page</a>!)</p>
<h2 id="introduction">Introduction</h2>
<p><strong>Six guys, one router</strong></p>
<p>On the 1st of October the CyberChallenge.IT project held an Attack/Defense CTF, in which one team for each of the 28 participating Italian universities was competing to be crowned as the CyberChallenge.IT champion and to have a chance to be selected for Team Italy during ECSC 2021.</p>
<p>We, along with other 4 people, were representing the Politecnico di Milano in this 8-hour competition. In the end, we placed 2nd, behind the University of Pisa and just ahead of the University of Verona.</p>
<p><img src="images/image2.png" alt=""></p>
<p>Among all the challenges, arguably, the most interesting was one called home_r00ter. It was a mixture of many different challenges, featuring command injections, reverse engineering, race conditions, and much more. For this reason, you should expect a long writeup, but we promise you: it's worth it! :)</p>
<p>The physical setup of the challenge consisted of 28 routers placed in the same location. Each team could remotely access its own router (and only that one) through the competition's VPN.</p>
<p><img src="images/image6.png" alt=""></p>
<p>We were provided with some files found in our main vulnbox. Among the files there were:</p>
<ul>
<li>A file called <code>cfgbin</code>, which was a 64-bit ARM executable</li>
<li><code>list.txt</code> An exhaustive list of every router's MAC and serial number</li>
<li><code>update_key</code> An hexadecimal string</li>
</ul>
<p>The router exposed ports 22 and 80, but both the webserver and the ssh required authentication for which we had no credentials :/.</p>
<h2 id="a-problem-arm-tic-binary">A Problem-ARM-tic Binary</h2>
<p><strong>If only we had an ARM processor on the tableâ€¦</strong></p>
<p>Looking at the decompiled code of cfgbin we found that the router SSID, the WPA key, and the web password (the same as the WPA key) were generated from the serial number and the MAC of the device.</p>
<p>Unfortunately, since this was an ARM executable, we couldn't run this code natively on our machine. Not knowing any other alternatives, we started creating a keygen script. This process turned out to be really nasty and eventually, after some googling, we opted for executing the binary by using QEMU (Still don't know what went wrong with the reversing :/).</p>
<p>Following <a href="https://gist.github.com/luk6xff/9f8d2520530a823944355e59343eadc1">this</a> guide, we could set up an arm64 environment with a fully functional gdb (with pwndbg). The advantage of QEMU is that it is not completely emulated. In fact, the executable used our system's syscall, and hence we could create every file it needed in our filesystem.</p>
<p>With gdb we could jump wherever we needed and skip the initial method that was blocking the execution <code>check_platform()</code> and the one that was generating random serials <code>gen_serials()</code>.</p>
<p>Looking in the <code>get_serial()</code> and <code>get_mac()</code> method we could see that the MAC needed to be stored in <code>/sys/class/net/ap0/address</code> and the serial in <code>/etc/serial</code>.</p>
<pre tabindex="0"><code>int __cdecl main(int argc, const char **argv, cons char **envp)
{
__int64 MAC; // ST18_8
__int64 SERIALE; // ST10_8

check_platform();
gen_serial();
gen_ssid();
gen_update_key();
MAC = get_mac();
SERIALE = get_serial();
gen_key(SERIALE, MAC);
return 0;
}
</code></pre><p>The binary of course needed to be patched because the path <code>/sys/class/net/ap0/address</code> couldn't exist in our machine's filesystem. We also patched the main method to make it only generate the key.</p>
<p>Now with a simple python script, we could generate not only our key but also the other players'.</p>
<p>We then realized that all this time we could have executed the code on the Raspberry Pi we were using as NFS server :))))))))).</p>
<h2 id="the-switcheroo">The Switcheroo</h2>
<p><strong>Read this like you're in front of a magician doing his show</strong></p>
<p>After recovering the password, we could connect to our router with that and the username <code>admin</code> (Mind you again: we could only connect to our router but not the other teams' routers).</p>
<p><img src="images/image7.png" alt=""></p>
<p>From there we were greeted with a page showing some (probably useless) information about the router and two other pages, containing some utilities and a page to update the router's firmware.</p>
<p><img src="images/image3.png" alt=""></p>
<p>The utilities consisted of a ping function and a traceroute function. After running a ping call, we instantly knew that whatever we were putting in the ping input was going directly into a shell. After experimenting with some command separators, we found <code>%0a</code> which was not in the blacklist and the usual <code>${IFS}</code> to insert spaces between parameters. This allowed us to start injecting arbitrary commands.</p>
<p><img src="images/image1.png" alt=""></p>
<p><img src="images/image4.png" alt=""></p>
<p>A few things caught our attention during our filesystem exploration:</p>
<ul>
<li>A <code>/flag</code> file containing all the flags</li>
<li><code>update.php</code> A PHP file which managed the update functionality</li>
<li><code>/update.sh</code> A shell file which was called by <code>update.php</code> to execute the update</li>
</ul>
<p>The goal was (somewhat) clear: obtain access to the other routers and then extract the flag file by using the command injection vulnerability. The problem was discovering how to connect to the other routers since we had access only to the web interface of the router and we did not have the password to ssh to our router.</p>
<p>A tip was given to everyone by the organizers: we needed to gain access by writing into <code>authorized_keys</code>.</p>
<p>We obtained the source code for all the PHP files and the shell files by manually &ldquo;cat-ing&rdquo; and receiving the output on our Utils panel.</p>
<p><img src="images/image5.png" alt=""></p>
<p>Looking into <code>update.php</code> we understood how the update was happening: the file that we uploaded was put as <code>/tmp/update.tar.cc</code>, its permissions were changed, and <code>update.sh</code> was called.</p>
<pre tabindex="0"><code>move_uploaded_file($_FILES[&#39;update&#39;][&#39;tmp_name&#39;], &#39;/tmp/update.tar.cc&#39;);
exec(&#34;/bin/chmod 777 /tmp/update.tar.cc&#34;);
exec(&#34;key=&#34;.escapeshellarg($_POST[&#39;password&#39;]).&#34; /bin/sh -c &#39;/usr/bin/sudo -u upgrade /bin/sh /update.sh&#39; 2&gt;&amp;1&#34;, $result);
</code></pre><p>At this point we tried putting our credentials in the <code>authorized_keys</code> file by writing a shell script, uploading it to find it later on as <code>/tmp/update.tar.cc</code>, and executing it via the command injection that we found earlier.</p>
<p>After some experimentation, we discovered that, although we could execute the shell script, we did not have the permissions to write where we wanted since the script was executed by user <code>www-data</code>, which didn't have a <code>home</code> folder and, hence, did not have a <code>.ssh</code> folder either.</p>
<p>We discovered that we had to access as the <code>upgrade</code> user and the only way to do so was through the <code>update.sh</code> script, which was executed as <code>upgrade</code> with <code>sudo</code> permissions.</p>
<p>Another hint from the organizers (&quot;toctou&quot;, Time Of Check Time Of Use) led us to the vulnerability in <code>update.sh</code>: the firmware tarball that we uploaded had to be signed (we didn't have the possibility of signing, since we didn't have the private key), but it could then be swapped for another tarball while it was checking the original signature (Between the call to openssl and the tar extraction in the following snippet), which would be then extracted in place of the signed tarball.</p>
<pre tabindex="0"><code>/bin/echo &#34;[+] Checking Signature&#34;
check=`/usr/bin/openssl dgst -sha256 -verify $pubkey -signature $sig $file`
if [ &#34;$check&#34; == &#34;Verified OK&#34; ]
then
        /bin/echo &#34;[+] Signature is valid!&#34;
        /bin/echo &#34;[+] Upgrading...&#34;
        /bin/tar -xvf $file -C /
        /bin/rm $sig
        /bin/echo &#34;[+] Done&#34;
else
        /bin/echo &#34;[-] Signature error, exiting...&#34;
        /bin/rm $sig
fi
</code></pre><p>After a big fail with locating and downloading an already signed tar from the router (The first time we accidentally truncated the tarball, leading to an invalid signature. After banging our head for a while we then printed the base64 of the tar and recovered the correct one.) we managed to make the swap work, albeit with a little help of the organizers which put a <code>sleep(3)</code> between the signature check and the tar extraction to make our race condition exploit work more consistently. We finally had ssh access to the router!</p>
<h2 id="inside-the-router">Inside the router</h2>
<p><strong>Sounds better than it really is</strong></p>
<p>We discovered from the <code>sudoers</code> file that the <code>upgrade</code> user had the possibility of running both <code>sudo /wifi/connect.sh</code> and <code>sudo /wifi/disconnect.sh</code>.</p>
<p><code>connect.sh</code> requires an SSID and a password and uses them to connect to that wifi network through WPA Supplicant. Conversely, <code>disconnect.sh</code> disconnects the router from that wifi network.</p>
<p>Fun fact: attempting to call <code>connect.sh</code> twice without disconnecting freezes the router, which was great considering we were in the last 30 minutes of the competition :)</p>
<p>After the admins restarted our router, we started to run our exploit with the help of pwntools:</p>
<pre tabindex="0"><code># The entries were in the form
# [router_IP, serial, MAC, password]
elencoTargets = [
[&#34;10.10.1.2&#34;,&#34;646244DCA8C684F52CBC6C98AFF0FA9B&#34;,&#34;7c:25:da:50:a0:2e&#34;,&#34;22ad2132194dc0105a2a&#34;]
       ,â€¦
]
nPort = 10000
conn = ssh(&#34;upgrade&#34;,&#34;10.10.6.2&#34;)

for target in targets:
   nPort+=14
   conn.run_to_end(&#34;sudo /bin/sh /wifi/connect.sh CyberChallenge-%s %s&#34; % (target[1][:4], target[3]))
   ipToAttack = conn.run_to_end(&#34;route -n | grep client0 | awk &#39;{print $1}&#39;&#34;)[0].decode(â€˜utf-8â€™)[:-1] + &#34;1&#34; #Extract the default gateway address
   subprocess.Popen(&#34;ssh upgrade@10.10.6.2 -L &#34; + str(n) + &#34;:&#34;+ipToAttack+&#34;:80&#34;, shell=True) #Open a tunnel from our 
   time.sleep(1) #Waiting for connection
   req=requests.post(&#34;http://admin:&#34;+target[3]+&#34;@localhost:&#34;+str(n)+&#34;/utils.php&#34;, data={&#34;action&#34;:&#34;ping&#34;,&#34;host&#34;: b&#34;127.0.0.1\ncat${IFS}/flag&#34;})
   flags=re.findall(r&#34;ccit\{[A-Za-z0-9]{25}\}&#34;,req.text)
   conn.run_to_end(&#34;sudo /bin/sh /wifi/disconnect.sh&#34;)
</code></pre><p>The exploit was quite complex: the router didn't have the binaries required to run such a thing simply, so we had to use a little trick to forward the connection to our machine and perform the real exploit locally.</p>
<p>Using the ssh connection, we executed the <code>connect.sh</code> script on the target SSID (This was generated in the binary <code>CyberChallenge-&lt;First 4 characters of the S.N.&gt;</code>) and using the WPA key, which was the same as the HTTP password.</p>
<p>Then we obtained the gateway address, which wasn't the same in every connection. On this address, we initialized the &quot;proxy&quot; that redirected every request on a local port to that remote host.</p>
<p>We had to change the port on every loop because the last port was already occupied by the connection in the previous iteration (for the lack of time the first and only version of this code had to be written quickly).</p>
<p>Now we could make a request that uses the ping vulnerability which returned all the flags.</p>
<p>In the end, it worked and, since we finished the exploit in the last few minutes, we managed to submit a grand total ofâ€¦ 9 flags! :D</p>
<h2 id="conclusion">Conclusion</h2>
<p><strong>Ok stop laughing this one is serious</strong></p>
<p>After such an odyssey, we wanted to conclude this really long writeup by telling the story of PoliTo. It's a story about unintended vulnerabilities, thinking outside the box, and competition ethics. In short: the team representing Politecnico di Torino managed to find out that the routers were situated in a nearby building and went there to connect directly to the routers with their PCs. They started flagging quite early and earned a lot of points with this challenge alone, putting us in the third position towards the end.</p>
<p>After the admins discovered this, they decided to take away all of their points for this challenge (even the SLA points, which would have put them in third place!). In the end, we got our second place, Verona got the third, and PoliTo, unfortunately, fell to the fourth position.</p>
<p>We will now speak from a personal standpoint and no longer representing the team: we feel like what happened to PoliTo was unfortunate. It was a harsh punishment for thinking outside the box and we believe that it's also the organizer's fault for not thinking about this problem beforehand. We can also understand the point that not everybody could do what they did since each team played from their own cities and couldn't physically access the routers. We also agree that in these dubious situations your best bet is to ask directly to the organizers.</p>
<p>However, we believe that the best course of action was not to entirely void their points for the challenge but to award them for doing something creative, something that actually resembles real hacking. We believe that what we did in CyberChallenge.IT was not just a game: it's a stepping stone in our path in cybersecurity.</p>
<p>In the end, we believe that we could have shared the second place between PoliMi and PoliTo, awarding them for their solution, while, at the same time, not penalizing us either for not having physical access to the routers.</p>
<p>So kudos to the University of Pisa, for being the undiscussed champions of this competition, kudos to the University of Verona, for getting very close to our score making it a really close call up until the last minute, but most importantly: <a href="https://twitter.com/search?q=%23jesuispolito&amp;src=typed_query">#JeSuisPoliTo</a> :)</p>

        </section>
        <div class="post-tags">
          
          
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/molteniluca/" rel="me" title="GitHub"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github" />
</svg></a><a class="border"></a><a class="soc" href="https://twitter.com/Luca__molteni/" rel="me" title="Twitter"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#twitter" />
</svg></a><a class="border"></a><a class="soc" href="https://www.linkedin.com/in/lmolteni/" rel="me" title="LinkedIn"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#linkedin" />
</svg></a><a class="border"></a></div>
  <div class="footer-info">
    2025  Â© Luca Molteni |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>



</div>
    </body>
</html>
